{"version":3,"sources":["Screens/Maths/IntegerPartition.js","Algorithms/NumberPartition.js","../node_modules/react-bootstrap/esm/CardDeck.js"],"names":["IntegerPartition","useState","partitions","setPartitions","Row","Col","title","md","CardDeck","isOption","setSample","sampleNum","console","log","Form","Group","Label","Control","defaultValue","id","onChange","number","isNaN","partitionMatrix","Array","fill","map","numberIndex","summandIndex","combosWithoutSummand","combosWithSummand","numberPartition","parseInt","document","getElementById","value","type","placeholder","Text","className","createWithBsPrefix"],"mappings":"qMAqDeA,UA9CU,KAAO,MAAD,EACOC,mBAAS,GADhB,mBACtBC,EADsB,KACVC,EADU,KAS7B,OACE,kBAAC,IAAD,KACE,kBAACC,EAAA,EAAD,KACE,kBAACC,EAAA,EAAD,KACE,kBAAC,IAAD,CAAMC,MAAM,qBAAZ,iQAOJ,kBAACF,EAAA,EAAD,KACE,kBAACC,EAAA,EAAD,CAAKE,GAAI,IACP,kBAACC,EAAA,EAAD,KACE,kBAAC,IAAD,CAAMF,MAAM,QAAQG,UAAQ,EAACC,UAjBpBC,IACjBC,QAAQC,IAAIF,KAiBF,kBAACG,EAAA,EAAD,KACE,kBAACA,EAAA,EAAKC,MAAN,KACE,kBAACD,EAAA,EAAKE,MAAN,yBACA,kBAACF,EAAA,EAAKG,QAAN,CACEC,aAAc,EACdC,GAAG,kBACHC,SA3BO,KACvBjB,ECPW,SAA0BkB,GACvC,GAAIC,MAAMD,IAAqB,MAAVA,EAAgB,MAAO,GAE5C,MAAME,EAAkBC,MAAMH,EAAS,GACpCI,KAAK,MACLC,IAAI,IACIF,MAAMH,EAAS,GAAGI,KAAK,OAQlC,IAAK,IAAIE,EAAc,EAAGA,GAAeN,EAAQM,GAAe,EAC9DJ,EAAgB,GAAGI,GAAe,EAOpC,IAAK,IAAIC,EAAe,EAAGA,GAAgBP,EAAQO,GAAgB,EACjEL,EAAgBK,GAAc,GAAK,EAKrC,IAAK,IAAIA,EAAe,EAAGA,GAAgBP,EAAQO,GAAgB,EACjE,IAAK,IAAID,EAAc,EAAGA,GAAeN,EAAQM,GAAe,EAC9D,GAAIC,EAAeD,EAGjBJ,EAAgBK,GAAcD,GAAeJ,EAAgBK,EAAe,GAAGD,OAC1E,CAYL,MAAME,EAAuBN,EAAgBK,EAAe,GAAGD,GACzDG,EAAoBP,EAAgBK,GAAcD,EAAcC,GAEtEL,EAAgBK,GAAcD,GAAeE,EAAuBC,EAK1E,OAAOP,EAAgBF,GAAQA,GD/CfU,CAAgBC,SAASC,SAASC,eAAe,mBAAmBC,UA2BlEC,KAAK,SACLC,YAAY,UAEd,kBAACvB,EAAA,EAAKwB,KAAN,CAAWC,UAAU,cAArB,uCAIN,kBAAC,IAAD,CAAMjC,MAAM,UAAUJ,S,gCE7ClC,YACesC,gBAAmB","file":"static/js/26.86bdc639.chunk.js","sourcesContent":["import React, { useState } from \"react\";\nimport { Row, Col, Form, CardDeck } from \"react-bootstrap\";\n\nimport Aux from \"../../hoc/_Aux\";\nimport Card from \"../../App/components/MainCard\";\nimport numberPartition from \"../../Algorithms/NumberPartition\";\n\nconst IntegerPartition = () => {\n  const [partitions, setPartitions] = useState(0);\n\n  const updatePartitions = () => {\n    setPartitions(numberPartition(parseInt(document.getElementById(\"partitionNumber\").value)));\n  };\n  const setSample = (sampleNum) => {\n    console.log(sampleNum);\n  };\n  return (\n    <Aux>\n      <Row>\n        <Col>\n          <Card title=\"Integer Partition\">\n            In number theory and combinatorics, a partition of a positive integer n, also called an\n            integer partition, is a way of writing n as a sum of positive integers. Two sums that\n            differ only in the order of their summands are considered the same partition.\n          </Card>\n        </Col>\n      </Row>\n      <Row>\n        <Col md={12}>\n          <CardDeck>\n            <Card title=\"Input\" isOption setSample={setSample}>\n              <Form>\n                <Form.Group>\n                  <Form.Label>Partition Number</Form.Label>\n                  <Form.Control\n                    defaultValue={0}\n                    id=\"partitionNumber\"\n                    onChange={updatePartitions}\n                    type=\"number\"\n                    placeholder=\"10...\"\n                  />\n                  <Form.Text className=\"text-muted\">Kindly Input The Partition Space</Form.Text>\n                </Form.Group>\n              </Form>\n            </Card>\n            <Card title=\"Output\">{partitions}</Card>\n          </CardDeck>\n        </Col>\n      </Row>\n    </Aux>\n  );\n};\n\nexport default IntegerPartition;\n","/**\n * @param {number} number\n * @return {number}\n */\nexport default function integerPartition(number) {\n  if (isNaN(number) || number == null) return [];\n  // Create partition matrix for solving this task using Dynamic Programming.\n  const partitionMatrix = Array(number + 1)\n    .fill(null)\n    .map(() => {\n      return Array(number + 1).fill(null);\n    });\n\n  // Fill partition matrix with initial values.\n\n  // Let's fill the first row that represents how many ways we would have\n  // to combine the numbers 1, 2, 3, ..., n with number 0. We would have zero\n  // ways obviously since with zero number we may form only zero.\n  for (let numberIndex = 1; numberIndex <= number; numberIndex += 1) {\n    partitionMatrix[0][numberIndex] = 0;\n  }\n\n  // Let's fill the first column. It represents the number of ways we can form\n  // number zero out of numbers 0, 0 and 1, 0 and 1 and 2, 0 and 1 and 2 and 3, ...\n  // Obviously there is only one way we could form number 0\n  // and it is with number 0 itself.\n  for (let summandIndex = 0; summandIndex <= number; summandIndex += 1) {\n    partitionMatrix[summandIndex][0] = 1;\n  }\n\n  // Now let's go through other possible options of how we could form number m out of\n  // summands 0, 1, ..., m using Dynamic Programming approach.\n  for (let summandIndex = 1; summandIndex <= number; summandIndex += 1) {\n    for (let numberIndex = 1; numberIndex <= number; numberIndex += 1) {\n      if (summandIndex > numberIndex) {\n        // If summand number is bigger then current number itself then just it won't add\n        // any new ways of forming the number. Thus we may just copy the number from row above.\n        partitionMatrix[summandIndex][numberIndex] = partitionMatrix[summandIndex - 1][numberIndex];\n      } else {\n        /*\n         * The number of combinations would equal to number of combinations of forming the same\n         * number but WITHOUT current summand number PLUS number of combinations of forming the\n         * <current number - current summand> number but WITH current summand.\n         *\n         * Example:\n         * Number of ways to form 5 using summands {0, 1, 2} would equal the SUM of:\n         * - number of ways to form 5 using summands {0, 1} (we've excluded summand 2)\n         * - number of ways to form 3 (because 5 - 2 = 3) using summands {0, 1, 2}\n         * (we've included summand 2)\n         */\n        const combosWithoutSummand = partitionMatrix[summandIndex - 1][numberIndex];\n        const combosWithSummand = partitionMatrix[summandIndex][numberIndex - summandIndex];\n\n        partitionMatrix[summandIndex][numberIndex] = combosWithoutSummand + combosWithSummand;\n      }\n    }\n  }\n\n  return partitionMatrix[number][number];\n}\n","import createWithBsPrefix from './createWithBsPrefix';\nexport default createWithBsPrefix('card-deck');"],"sourceRoot":""}