{"version":3,"sources":["Screens/Strings/WordBreak.js","../node_modules/react-bootstrap/esm/CardDeck.js","Algorithms/LongestCommonSubsequence.js"],"names":["WordBreak","_useState","useState","_useState2","Object","_home_maxplanko89_Desktop_ALGO_Algo_Project_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_0__","dictionary","setDictionary","_useState3","_useState4","myString","setMyString","_useState5","_useState6","wordBreak","setWordBreak","_useState7","_useState8","init","setInit","react__WEBPACK_IMPORTED_MODULE_1___default","a","createElement","_hoc_Aux__WEBPACK_IMPORTED_MODULE_6__","react_bootstrap__WEBPACK_IMPORTED_MODULE_2__","react_bootstrap__WEBPACK_IMPORTED_MODULE_3__","_App_components_MainCard__WEBPACK_IMPORTED_MODULE_7__","title","react_bootstrap__WEBPACK_IMPORTED_MODULE_4__","md","react_bootstrap__WEBPACK_IMPORTED_MODULE_5__","Group","controlId","Label","Control","defaultValue","id","onChange","document","getElementById","value","longestCommonSubsequence","split","join","type","placeholder","Text","className","_createWithBsPrefix__WEBPACK_IMPORTED_MODULE_0__","__webpack_require__","__webpack_exports__","set1","set2","lcsMatrix","Array","length","fill","map","columnIndex","rowIndex","Math","max","longestSequence","unshift","d"],"mappings":"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","file":"static/js/16.50e8d711.chunk.js","sourcesContent":["import React, { useState } from \"react\";\nimport { Row, Col, Form, CardDeck } from \"react-bootstrap\";\n\nimport Aux from \"../../hoc/_Aux\";\nimport Card from \"../../App/components/MainCard\";\nimport longestCommonSubsequence from \"../../Algorithms/LongestCommonSubsequence\";\n\nconst WordBreak = () => {\n  const [dictionary, setDictionary] = useState(\"\");\n  const [myString, setMyString] = useState(\"\");\n  const [wordBreak, setWordBreak] = useState(\"---\");\n  const [init, setInit] = useState(false);\n\n  const updateDictionary = () => {\n    let dictionary = document.getElementById(\"dictionary\").value;\n    setDictionary(dictionary);\n    setWordBreak(longestCommonSubsequence(dictionary.split(\"\"), myString.split(\"\")).join(\"\"));\n    setInit(true);\n  };\n  const updateMyString = () => {\n    let myString = document.getElementById(\"myString\").value;\n    setMyString(myString);\n    setWordBreak(longestCommonSubsequence(dictionary.split(\"\"), myString.split(\"\")).join(\"\"));\n    setInit(true);\n  };\n  return (\n    <Aux>\n      <Row>\n        <Col>\n          <Card title=\"Word Break\">\n            Longest Common Subsequence Problem has two sequences and we have to find the length of\n            longest subsequence present in both of them. A subsequence is a sequence that appears in\n            the same relative order, but not necessarily contiguous.\n          </Card>\n        </Col>\n      </Row>\n      <Row>\n        <Col>\n          <CardDeck>\n            <Card title=\"Input\">\n              <Row>\n                <Col md={12}>\n                  <Form>\n                    <Form.Group controlId=\"formBasicEmail\">\n                      <Form.Label>Input Disctionary</Form.Label>\n                      <Form.Control\n                        defaultValue={dictionary}\n                        id=\"dictionary\"\n                        onChange={updateDictionary}\n                        type=\"text\"\n                        placeholder=\"Cat Dog Apple Man Butter...\"\n                      />\n                      <Form.Text className=\"text-muted\">Kindly Input Words with Spaces</Form.Text>\n                    </Form.Group>\n                    <Form.Group controlId=\"exampleForm.ControlTextarea1\">\n                      <Form.Label>Input String</Form.Label>\n                      <Form.Control\n                        defaultValue={myString}\n                        id=\"myString\"\n                        onChange={updateMyString}\n                        type=\"text\"\n                        placeholder=\"myapple...\"\n                      />\n                      <Form.Text className=\"text-muted\">\n                        Kindly Input string without spaces\n                      </Form.Text>\n                    </Form.Group>\n                  </Form>\n                </Col>\n              </Row>\n            </Card>\n            <Card title=\"Output\">{init ? (wordBreak ? \"Possible\" : \"Not Possible\") : \"---\"}</Card>\n          </CardDeck>\n        </Col>\n      </Row>\n    </Aux>\n  );\n};\n\nexport default WordBreak;\n","import createWithBsPrefix from './createWithBsPrefix';\nexport default createWithBsPrefix('card-deck');","/**\n * @param {string[]} set1\n * @param {string[]} set2\n * @return {string[]}\n */\nexport default function longestCommonSubsequence(set1, set2) {\n  // Init LCS matrix.\n  const lcsMatrix = Array(set2.length + 1)\n    .fill(null)\n    .map(() => Array(set1.length + 1).fill(null));\n\n  // Fill first row with zeros.\n  for (let columnIndex = 0; columnIndex <= set1.length; columnIndex += 1) {\n    lcsMatrix[0][columnIndex] = 0;\n  }\n\n  // Fill first column with zeros.\n  for (let rowIndex = 0; rowIndex <= set2.length; rowIndex += 1) {\n    lcsMatrix[rowIndex][0] = 0;\n  }\n\n  // Fill rest of the column that correspond to each of two strings.\n  for (let rowIndex = 1; rowIndex <= set2.length; rowIndex += 1) {\n    for (let columnIndex = 1; columnIndex <= set1.length; columnIndex += 1) {\n      if (set1[columnIndex - 1] === set2[rowIndex - 1]) {\n        lcsMatrix[rowIndex][columnIndex] = lcsMatrix[rowIndex - 1][columnIndex - 1] + 1;\n      } else {\n        lcsMatrix[rowIndex][columnIndex] = Math.max(\n          lcsMatrix[rowIndex - 1][columnIndex],\n          lcsMatrix[rowIndex][columnIndex - 1]\n        );\n      }\n    }\n  }\n\n  // Calculate LCS based on LCS matrix.\n  if (!lcsMatrix[set2.length][set1.length]) {\n    // If the length of largest common string is zero then return empty string.\n    return [\"\"];\n  }\n\n  const longestSequence = [];\n  let columnIndex = set1.length;\n  let rowIndex = set2.length;\n\n  while (columnIndex > 0 || rowIndex > 0) {\n    if (set1[columnIndex - 1] === set2[rowIndex - 1]) {\n      // Move by diagonal left-top.\n      longestSequence.unshift(set1[columnIndex - 1]);\n      columnIndex -= 1;\n      rowIndex -= 1;\n    } else if (lcsMatrix[rowIndex][columnIndex] === lcsMatrix[rowIndex][columnIndex - 1]) {\n      // Move left.\n      columnIndex -= 1;\n    } else {\n      // Move up.\n      rowIndex -= 1;\n    }\n  }\n\n  return longestSequence;\n}\n"],"sourceRoot":""}