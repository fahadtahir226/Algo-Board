{"version":3,"sources":["Algorithms/ShortestCommonSuperSequence.js","Screens/Sets/ShortestCommonSuperSequence.js","../node_modules/react-bootstrap/esm/CardDeck.js","Algorithms/LongestCommonSubsequence.js"],"names":["shortestCommonSupersequence","set1","set2","lcs","longestCommonSubsequence","length","concat","supersequence","setIndex1","setIndex2","lcsIndex","setOnHold1","setOnHold2","push","slice","LongestCommonSubsequence","_useState","useState","_useState2","Object","slicedToArray","str1","setStr1","_useState3","_useState4","str2","setStr2","_useState5","_useState6","commonStr","setCommonStr","react_default","a","createElement","_Aux","Row","Col","MainCard","title","CardDeck","md","Form","Group","controlId","Label","Control","defaultValue","id","onChange","firstSeq","document","getElementById","value","ShortestCommonSuperSequence","split","join","type","placeholder","Text","className","secondSeq","_createWithBsPrefix__WEBPACK_IMPORTED_MODULE_0__","__webpack_require__","__webpack_exports__","lcsMatrix","Array","fill","map","columnIndex","rowIndex","Math","max","longestSequence","unshift","d"],"mappings":"uLAQe,SAASA,EAA4BC,EAAMC,GAExD,IAAMC,EAAMC,YAAyBH,EAAMC,GAI3C,GAAmB,IAAfC,EAAIE,QAA2B,KAAXF,EAAI,GAC1B,OAAOF,EAAKK,OAAOJ,GAYrB,IARA,IAAIK,EAAgB,GAEhBC,EAAY,EACZC,EAAY,EACZC,EAAW,EACXC,GAAa,EACbC,GAAa,EAEVF,EAAWP,EAAIE,QAEhBG,EAAYP,EAAKI,SACdM,GAAcV,EAAKO,KAAeL,EAAIO,GAIzCC,GAAa,GAHbJ,EAAcM,KAAKZ,EAAKO,IACxBA,GAAa,IAObC,EAAYP,EAAKG,SACdO,GAAcV,EAAKO,KAAeN,EAAIO,GAIzCE,GAAa,GAHbL,EAAcM,KAAKX,EAAKO,IACxBA,GAAa,IAObE,GAAcC,IAChBL,EAAcM,KAAKV,EAAIO,IACvBA,GAAY,EACZF,GAAa,EACbC,GAAa,EACbE,GAAa,EACbC,GAAa,GAcjB,OATIJ,EAAYP,EAAKI,SACnBE,EAAgBA,EAAcD,OAAOL,EAAKa,MAAMN,KAI9CC,EAAYP,EAAKG,SACnBE,EAAgBA,EAAcD,OAAOJ,EAAKY,MAAML,KAG3CF,ECMMQ,UApEkB,WAAM,IAAAC,EACbC,mBAAS,IADIC,EAAAC,OAAAC,EAAA,EAAAD,CAAAH,EAAA,GAC9BK,EAD8BH,EAAA,GACxBI,EADwBJ,EAAA,GAAAK,EAEbN,mBAAS,IAFIO,EAAAL,OAAAC,EAAA,EAAAD,CAAAI,EAAA,GAE9BE,EAF8BD,EAAA,GAExBE,EAFwBF,EAAA,GAAAG,EAGHV,mBAAS,IAHNW,EAAAT,OAAAC,EAAA,EAAAD,CAAAQ,EAAA,GAG9BE,EAH8BD,EAAA,GAGnBE,EAHmBF,EAAA,GAerC,OACEG,EAAAC,EAAAC,cAACC,EAAA,EAAD,KACEH,EAAAC,EAAAC,cAACE,EAAA,EAAD,KACEJ,EAAAC,EAAAC,cAACG,EAAA,EAAD,KACEL,EAAAC,EAAAC,cAACI,EAAA,EAAD,CAAMC,MAAM,iCAAZ,8KAMJP,EAAAC,EAAAC,cAACE,EAAA,EAAD,KACEJ,EAAAC,EAAAC,cAACG,EAAA,EAAD,KACEL,EAAAC,EAAAC,cAACM,EAAA,EAAD,KACER,EAAAC,EAAAC,cAACI,EAAA,EAAD,CAAMC,MAAM,SACVP,EAAAC,EAAAC,cAACE,EAAA,EAAD,KACEJ,EAAAC,EAAAC,cAACG,EAAA,EAAD,CAAKI,GAAI,IACPT,EAAAC,EAAAC,cAACQ,EAAA,EAAD,KACEV,EAAAC,EAAAC,cAACQ,EAAA,EAAKC,MAAN,CAAYC,UAAU,kBACpBZ,EAAAC,EAAAC,cAACQ,EAAA,EAAKG,MAAN,qBACAb,EAAAC,EAAAC,cAACQ,EAAA,EAAKI,QAAN,CACEC,aAAczB,EACd0B,GAAG,OACHC,SAhCH,WACjB,IAAIC,EAAWC,SAASC,eAAe,QAAQC,MAC/C9B,EAAQ2B,GACRnB,EAAauB,EAA4BJ,EAASK,MAAM,IAAK7B,EAAK6B,MAAM,KAAKC,KAAK,MA8B9DC,KAAK,OACLC,YAAY,iBAEd1B,EAAAC,EAAAC,cAACQ,EAAA,EAAKiB,KAAN,CAAWC,UAAU,cAArB,8BAEF5B,EAAAC,EAAAC,cAACQ,EAAA,EAAKC,MAAN,CAAYC,UAAU,gCACpBZ,EAAAC,EAAAC,cAACQ,EAAA,EAAKG,MAAN,sBACAb,EAAAC,EAAAC,cAACQ,EAAA,EAAKI,QAAN,CACEC,aAAcrB,EACdsB,GAAG,OACHC,SAtCH,WACjB,IAAIY,EAAYV,SAASC,eAAe,QAAQC,MAChD1B,EAAQkC,GACR9B,EAAauB,EAA4BhC,EAAKiC,MAAM,IAAKM,EAAUN,MAAM,KAAKC,KAAK,MAoC/DC,KAAK,OACLC,YAAY,iBAEd1B,EAAAC,EAAAC,cAACQ,EAAA,EAAKiB,KAAN,CAAWC,UAAU,cAArB,mCAMV5B,EAAAC,EAAAC,cAACI,EAAA,EAAD,CAAMC,MAAM,UACVP,EAAAC,EAAAC,cAAA,KAAG0B,UAAU,QAAQ9B,EAAUxB,OAAS,EAAI,MAAQwB,0CClElE,IAAAgC,EAAAC,EAAA,IACeC,EAAA,EAAA5C,OAAA0C,EAAA,GAAkB,8CCIlB,SAASzD,EAAyBH,EAAMC,GAOrD,IALA,IAAM8D,EAAYC,MAAM/D,EAAKG,OAAS,GACnC6D,KAAK,MACLC,IAAI,kBAAMF,MAAMhE,EAAKI,OAAS,GAAG6D,KAAK,QAGhCE,EAAc,EAAGA,GAAenE,EAAKI,OAAQ+D,GAAe,EACnEJ,EAAU,GAAGI,GAAe,EAI9B,IAAK,IAAIC,EAAW,EAAGA,GAAYnE,EAAKG,OAAQgE,GAAY,EAC1DL,EAAUK,GAAU,GAAK,EAI3B,IAAK,IAAIA,EAAW,EAAGA,GAAYnE,EAAKG,OAAQgE,GAAY,EAC1D,IAAK,IAAID,EAAc,EAAGA,GAAenE,EAAKI,OAAQ+D,GAAe,EAC/DnE,EAAKmE,EAAc,KAAOlE,EAAKmE,EAAW,GAC5CL,EAAUK,GAAUD,GAAeJ,EAAUK,EAAW,GAAGD,EAAc,GAAK,EAE9EJ,EAAUK,GAAUD,GAAeE,KAAKC,IACtCP,EAAUK,EAAW,GAAGD,GACxBJ,EAAUK,GAAUD,EAAc,IAO1C,IAAKJ,EAAU9D,EAAKG,QAAQJ,EAAKI,QAE/B,MAAO,CAAC,IAOV,IAJA,IAAMmE,EAAkB,GACpBJ,EAAcnE,EAAKI,OACnBgE,EAAWnE,EAAKG,OAEb+D,EAAc,GAAKC,EAAW,GAC/BpE,EAAKmE,EAAc,KAAOlE,EAAKmE,EAAW,IAE5CG,EAAgBC,QAAQxE,EAAKmE,EAAc,IAC3CA,GAAe,EACfC,GAAY,GACHL,EAAUK,GAAUD,KAAiBJ,EAAUK,GAAUD,EAAc,GAEhFA,GAAe,EAGfC,GAAY,EAIhB,OAAOG,EA5DTV,EAAAY,EAAAX,EAAA,sBAAA3D","file":"static/js/15.5777327a.chunk.js","sourcesContent":["import longestCommonSubsequence from \"./LongestCommonSubsequence\";\n\n/**\n * @param {string[]} set1\n * @param {string[]} set2\n * @return {string[]}\n */\n\nexport default function shortestCommonSupersequence(set1, set2) {\n  // Let's first find the longest common subsequence of two sets.\n  const lcs = longestCommonSubsequence(set1, set2);\n\n  // If LCS is empty then the shortest common supersequence would be just\n  // concatenation of two sequences.\n  if (lcs.length === 1 && lcs[0] === \"\") {\n    return set1.concat(set2);\n  }\n\n  // Now let's add elements of set1 and set2 in order before/inside/after the LCS.\n  let supersequence = [];\n\n  let setIndex1 = 0;\n  let setIndex2 = 0;\n  let lcsIndex = 0;\n  let setOnHold1 = false;\n  let setOnHold2 = false;\n\n  while (lcsIndex < lcs.length) {\n    // Add elements of the first set to supersequence in correct order.\n    if (setIndex1 < set1.length) {\n      if (!setOnHold1 && set1[setIndex1] !== lcs[lcsIndex]) {\n        supersequence.push(set1[setIndex1]);\n        setIndex1 += 1;\n      } else {\n        setOnHold1 = true;\n      }\n    }\n\n    // Add elements of the second set to supersequence in correct order.\n    if (setIndex2 < set2.length) {\n      if (!setOnHold2 && set2[setIndex2] !== lcs[lcsIndex]) {\n        supersequence.push(set2[setIndex2]);\n        setIndex2 += 1;\n      } else {\n        setOnHold2 = true;\n      }\n    }\n\n    // Add LCS element to the supersequence in correct order.\n    if (setOnHold1 && setOnHold2) {\n      supersequence.push(lcs[lcsIndex]);\n      lcsIndex += 1;\n      setIndex1 += 1;\n      setIndex2 += 1;\n      setOnHold1 = false;\n      setOnHold2 = false;\n    }\n  }\n\n  // Attach set1 leftovers.\n  if (setIndex1 < set1.length) {\n    supersequence = supersequence.concat(set1.slice(setIndex1));\n  }\n\n  // Attach set2 leftovers.\n  if (setIndex2 < set2.length) {\n    supersequence = supersequence.concat(set2.slice(setIndex2));\n  }\n\n  return supersequence;\n}\n","import React, { useState } from \"react\";\nimport { Row, Col, Form, CardDeck } from \"react-bootstrap\";\n\nimport Aux from \"../../hoc/_Aux\";\nimport Card from \"../../App/components/MainCard\";\nimport ShortestCommonSuperSequence from \"../../Algorithms/ShortestCommonSuperSequence\";\n\nconst LongestCommonSubsequence = () => {\n  const [str1, setStr1] = useState(\"\");\n  const [str2, setStr2] = useState(\"\");\n  const [commonStr, setCommonStr] = useState(\"\");\n\n  const updateStr1 = () => {\n    let firstSeq = document.getElementById(\"str1\").value;\n    setStr1(firstSeq);\n    setCommonStr(ShortestCommonSuperSequence(firstSeq.split(\"\"), str2.split(\"\")).join(\"\"));\n  };\n  const updateStr2 = () => {\n    let secondSeq = document.getElementById(\"str2\").value;\n    setStr2(secondSeq);\n    setCommonStr(ShortestCommonSuperSequence(str1.split(\"\"), secondSeq.split(\"\")).join(\"\"));\n  };\n  return (\n    <Aux>\n      <Row>\n        <Col>\n          <Card title=\"Shortest Common Supersequence\">\n            In Shortest Common Supersequence are given two strings str1 and str2, the task is to\n            find the length of the shortest string that has both str1 and str2 as subsequences.\n          </Card>\n        </Col>\n      </Row>\n      <Row>\n        <Col>\n          <CardDeck>\n            <Card title=\"Input\">\n              <Row>\n                <Col md={12}>\n                  <Form>\n                    <Form.Group controlId=\"formBasicEmail\">\n                      <Form.Label>First String</Form.Label>\n                      <Form.Control\n                        defaultValue={str1}\n                        id=\"str1\"\n                        onChange={updateStr1}\n                        type=\"text\"\n                        placeholder=\"My String...\"\n                      />\n                      <Form.Text className=\"text-muted\">Kindly Input First String</Form.Text>\n                    </Form.Group>\n                    <Form.Group controlId=\"exampleForm.ControlTextarea1\">\n                      <Form.Label>Second String</Form.Label>\n                      <Form.Control\n                        defaultValue={str2}\n                        id=\"str2\"\n                        onChange={updateStr2}\n                        type=\"text\"\n                        placeholder=\"My String...\"\n                      />\n                      <Form.Text className=\"text-muted\">Kindly Input Second String</Form.Text>\n                    </Form.Group>\n                  </Form>\n                </Col>\n              </Row>\n            </Card>\n            <Card title=\"Output\">\n              <p className=\"ml-3\">{commonStr.length < 1 ? \"---\" : commonStr}</p>\n            </Card>\n          </CardDeck>\n        </Col>\n      </Row>\n    </Aux>\n  );\n};\n\nexport default LongestCommonSubsequence;\n","import createWithBsPrefix from './createWithBsPrefix';\nexport default createWithBsPrefix('card-deck');","/**\n * @param {string[]} set1\n * @param {string[]} set2\n * @return {string[]}\n */\nexport default function longestCommonSubsequence(set1, set2) {\n  // Init LCS matrix.\n  const lcsMatrix = Array(set2.length + 1)\n    .fill(null)\n    .map(() => Array(set1.length + 1).fill(null));\n\n  // Fill first row with zeros.\n  for (let columnIndex = 0; columnIndex <= set1.length; columnIndex += 1) {\n    lcsMatrix[0][columnIndex] = 0;\n  }\n\n  // Fill first column with zeros.\n  for (let rowIndex = 0; rowIndex <= set2.length; rowIndex += 1) {\n    lcsMatrix[rowIndex][0] = 0;\n  }\n\n  // Fill rest of the column that correspond to each of two strings.\n  for (let rowIndex = 1; rowIndex <= set2.length; rowIndex += 1) {\n    for (let columnIndex = 1; columnIndex <= set1.length; columnIndex += 1) {\n      if (set1[columnIndex - 1] === set2[rowIndex - 1]) {\n        lcsMatrix[rowIndex][columnIndex] = lcsMatrix[rowIndex - 1][columnIndex - 1] + 1;\n      } else {\n        lcsMatrix[rowIndex][columnIndex] = Math.max(\n          lcsMatrix[rowIndex - 1][columnIndex],\n          lcsMatrix[rowIndex][columnIndex - 1]\n        );\n      }\n    }\n  }\n\n  // Calculate LCS based on LCS matrix.\n  if (!lcsMatrix[set2.length][set1.length]) {\n    // If the length of largest common string is zero then return empty string.\n    return [\"\"];\n  }\n\n  const longestSequence = [];\n  let columnIndex = set1.length;\n  let rowIndex = set2.length;\n\n  while (columnIndex > 0 || rowIndex > 0) {\n    if (set1[columnIndex - 1] === set2[rowIndex - 1]) {\n      // Move by diagonal left-top.\n      longestSequence.unshift(set1[columnIndex - 1]);\n      columnIndex -= 1;\n      rowIndex -= 1;\n    } else if (lcsMatrix[rowIndex][columnIndex] === lcsMatrix[rowIndex][columnIndex - 1]) {\n      // Move left.\n      columnIndex -= 1;\n    } else {\n      // Move up.\n      rowIndex -= 1;\n    }\n  }\n\n  return longestSequence;\n}\n"],"sourceRoot":""}