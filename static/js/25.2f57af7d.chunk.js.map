{"version":3,"sources":["Screens/Sets/LongestIncreasingSubsequence.js","Algorithms/LongestIncreasingSubsequence.js","../node_modules/react-bootstrap/esm/CardDeck.js"],"names":["LongestIncreasingSubsequence","_useState","useState","_useState2","Object","slicedToArray","seq","_useState3","_useState4","longest","setLongest","_useState5","key","values","_useState6","graphData","setGraphData","react_default","a","createElement","_Aux","Row","Col","MainCard","title","md","CardDeck","Form","Group","Label","Control","defaultValue","id","onChange","graph","data","document","getElementById","value","split","map","item","parseInt","isNaN","length","pop","sequence","lengthsArray","Array","fill","previousElementIndex","currentElementIndex","newLength","longestIncreasingLength","i","longestIncreasingSubsequence","forEach","push","type","placeholder","Text","className","width","react_nvd3_min_default","tooltip","enabled","datum","x","y","height","showValues","_createWithBsPrefix__WEBPACK_IMPORTED_MODULE_0__","__webpack_require__","__webpack_exports__"],"mappings":"gMAqFeA,UA7EsB,WAAM,IAAAC,EACnBC,mBAAS,IADUC,EAAAC,OAAAC,EAAA,EAAAD,CAAAH,EAAA,GAClCK,EADkCH,EAAA,GAAAI,GAAAJ,EAAA,GAEXD,mBAAS,IAFEM,EAAAJ,OAAAC,EAAA,EAAAD,CAAAG,EAAA,GAElCE,EAFkCD,EAAA,GAEzBE,EAFyBF,EAAA,GAAAG,EAGPT,mBAAS,CACzC,CACEU,IAAK,oBACLC,OAAQ,MAN6BC,EAAAV,OAAAC,EAAA,EAAAD,CAAAO,EAAA,GAGlCI,EAHkCD,EAAA,GAGvBE,EAHuBF,EAAA,GAwBzC,OACEG,EAAAC,EAAAC,cAACC,EAAA,EAAD,KACEH,EAAAC,EAAAC,cAACE,EAAA,EAAD,KACEJ,EAAAC,EAAAC,cAACG,EAAA,EAAD,KACEL,EAAAC,EAAAC,cAACI,EAAA,EAAD,CAAMC,MAAM,kCAAZ,qMAOJP,EAAAC,EAAAC,cAACE,EAAA,EAAD,KACEJ,EAAAC,EAAAC,cAACG,EAAA,EAAD,CAAKG,GAAI,IACPR,EAAAC,EAAAC,cAACO,EAAA,EAAD,KACET,EAAAC,EAAAC,cAACI,EAAA,EAAD,CAAMC,MAAM,SACVP,EAAAC,EAAAC,cAACE,EAAA,EAAD,KACEJ,EAAAC,EAAAC,cAACG,EAAA,EAAD,KACEL,EAAAC,EAAAC,cAACQ,EAAA,EAAD,KACEV,EAAAC,EAAAC,cAACQ,EAAA,EAAKC,MAAN,KACEX,EAAAC,EAAAC,cAACQ,EAAA,EAAKE,MAAN,sBACAZ,EAAAC,EAAAC,cAACQ,EAAA,EAAKG,QAAN,CACEC,aAAczB,EACd0B,GAAG,8BACHC,SArCJ,WAChB,IAAIC,EAAQ,CACRtB,IAAK,oBACLC,OAAQ,IAEVsB,EAAOC,SAASC,eAAe,+BAA+BC,MAAMC,MAAM,KAC5EJ,EAAOA,EAAKK,IAAI,SAACC,GAAD,OAAUC,SAASD,KAC/BE,MAAMR,EAAKA,EAAKS,OAAS,KAAKT,EAAKU,MACvCnC,ECnBW,SAAwCoC,GASrD,IALA,IAAMC,EAAeC,MAAMF,EAASF,QAAQK,KAAK,GAE7CC,EAAuB,EACvBC,EAAsB,EAEnBA,EAAsBL,EAASF,QAAQ,CAC5C,GAAIE,EAASI,GAAwBJ,EAASK,GAAsB,CAKlE,IAAMC,EAAYL,EAAaG,GAAwB,EACnDE,EAAYL,EAAaI,KAG3BJ,EAAaI,GAAuBC,IAKxCF,GAAwB,KAIKC,IAC3BA,GAAuB,EACvBD,EAAuB,GAQ3B,IAFA,IAAIG,EAA0B,EAErBC,EAAI,EAAGA,EAAIP,EAAaH,OAAQU,GAAK,EACxCP,EAAaO,GAAKD,IACpBA,EAA0BN,EAAaO,IAI3C,OAAOD,EDzBME,CAA6BpB,IACxCA,EAAKqB,QAAQ,SAAClB,EAAO1B,GACnBsB,EAAMrB,OAAO4C,KAAK,CAAE7C,MAAK0B,YAE3BtB,EAAa,CAACkB,KA0BMwB,KAAK,OACLC,YAAY,cAEd1C,EAAAC,EAAAC,cAACQ,EAAA,EAAKiC,KAAN,CAAWC,UAAU,cAArB,wCAMV5C,EAAAC,EAAAC,cAACI,EAAA,EAAD,CAAMuC,MAAM,MAAMtC,MAAM,UAAxB,mCACmCf,EACjCQ,EAAAC,EAAAC,cAAC4C,EAAA7C,EAAD,CACE8C,QAAS,CAAEC,SAAS,GACpBP,KAAK,mBACLQ,MAAOnD,EACPoD,EAAE,MACFC,EAAE,QACFC,OAAQ,IACRP,MAAO,IACPQ,YAAU,2CE3E1B,IAAAC,EAAAC,EAAA,IACeC,EAAA,EAAArE,OAAAmE,EAAA,GAAkB","file":"static/js/25.2f57af7d.chunk.js","sourcesContent":["import React, { useState } from \"react\";\nimport { Row, Col, Form, CardDeck } from \"react-bootstrap\";\nimport NVD3Chart from \"react-nvd3\";\n\nimport Aux from \"../../hoc/_Aux\";\nimport Card from \"../../App/components/MainCard\";\nimport longestIncreasingSubsequence from \"../../Algorithms/LongestIncreasingSubsequence\";\n\nconst LongestIncreasingSubsequence = () => {\n  const [seq, setSeq] = useState([]);\n  const [longest, setLongest] = useState(0);\n  const [graphData, setGraphData] = useState([\n    {\n      key: \"Cumulative Return\",\n      values: [],\n    },\n  ]);\n\n  const updateLIS = () => {\n    let graph = {\n        key: \"Cumulative Return\",\n        values: [],\n      },\n      data = document.getElementById(\"longest_increasing_sequence\").value.split(\" \");\n    data = data.map((item) => parseInt(item));\n    if (isNaN(data[data.length - 1])) data.pop();\n    setLongest(longestIncreasingSubsequence(data));\n    data.forEach((value, key) => {\n      graph.values.push({ key, value });\n    });\n    setGraphData([graph]);\n  };\n  return (\n    <Aux>\n      <Row>\n        <Col>\n          <Card title=\"Longest Increasing Subsequence\">\n            The Longest Increasing Subsequence (LIS) problem is to find the length of the longest\n            subsequence of a given sequence such that all elements of the subsequence are sorted in\n            increasing order.\n          </Card>\n        </Col>\n      </Row>\n      <Row>\n        <Col md={12}>\n          <CardDeck>\n            <Card title=\"Input\">\n              <Row>\n                <Col>\n                  <Form>\n                    <Form.Group>\n                      <Form.Label>Number Series</Form.Label>\n                      <Form.Control\n                        defaultValue={seq}\n                        id=\"longest_increasing_sequence\"\n                        onChange={updateLIS}\n                        type=\"text\"\n                        placeholder=\"1 2 3 ...\"\n                      />\n                      <Form.Text className=\"text-muted\">Kindly Input Numbers with space</Form.Text>\n                    </Form.Group>\n                  </Form>\n                </Col>\n              </Row>\n            </Card>\n            <Card width=\"70%\" title=\"Output\">\n              Longest Increasing Subsequence: {longest}\n              <NVD3Chart\n                tooltip={{ enabled: true }}\n                type=\"discreteBarChart\"\n                datum={graphData}\n                x=\"key\"\n                y=\"value\"\n                height={300}\n                width={400}\n                showValues\n              />\n            </Card>\n          </CardDeck>\n        </Col>\n      </Row>\n    </Aux>\n  );\n};\n\nexport default LongestIncreasingSubsequence;\n","/**\n * Dynamic programming approach to find longest increasing subsequence.\n * Complexity: O(n * n)\n *\n * @param {number[]} sequence\n * @return {number}\n */\nexport default function dpLongestIncreasingSubsequence(sequence) {\n  // Create array with longest increasing substrings length and\n  // fill it with 1-s that would mean that each element of the sequence\n  // is itself a minimum increasing subsequence.\n  const lengthsArray = Array(sequence.length).fill(1);\n\n  let previousElementIndex = 0;\n  let currentElementIndex = 1;\n\n  while (currentElementIndex < sequence.length) {\n    if (sequence[previousElementIndex] < sequence[currentElementIndex]) {\n      // If current element is bigger then the previous one then\n      // current element is a part of increasing subsequence which\n      // length is by one bigger then the length of increasing subsequence\n      // for previous element.\n      const newLength = lengthsArray[previousElementIndex] + 1;\n      if (newLength > lengthsArray[currentElementIndex]) {\n        // Increase only if previous element would give us bigger subsequence length\n        // then we already have for current element.\n        lengthsArray[currentElementIndex] = newLength;\n      }\n    }\n\n    // Move previous element index right.\n    previousElementIndex += 1;\n\n    // If previous element index equals to current element index then\n    // shift current element right and reset previous element index to zero.\n    if (previousElementIndex === currentElementIndex) {\n      currentElementIndex += 1;\n      previousElementIndex = 0;\n    }\n  }\n\n  // Find the biggest element in lengthsArray.\n  // This number is the biggest length of increasing subsequence.\n  let longestIncreasingLength = 0;\n\n  for (let i = 0; i < lengthsArray.length; i += 1) {\n    if (lengthsArray[i] > longestIncreasingLength) {\n      longestIncreasingLength = lengthsArray[i];\n    }\n  }\n\n  return longestIncreasingLength;\n}\n","import createWithBsPrefix from './createWithBsPrefix';\nexport default createWithBsPrefix('card-deck');"],"sourceRoot":""}