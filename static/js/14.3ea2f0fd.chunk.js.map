{"version":3,"sources":["Screens/Sets/LongestCommonSubsequence.js","../node_modules/react-bootstrap/esm/CardDeck.js","Algorithms/LongestCommonSubsequence.js"],"names":["LongestCommonSubsequence","useState","str1","setStr1","str2","setStr2","commonStr","setCommonStr","title","md","Group","controlId","Label","Control","defaultValue","id","onChange","firstSeq","document","getElementById","value","longestCommonSubsequence","split","join","type","placeholder","Text","className","secondSeq","length","createWithBsPrefix","set1","set2","lcsMatrix","Array","fill","map","columnIndex","rowIndex","Math","max","longestSequence","unshift"],"mappings":"6MA4EeA,UArEkB,KAAO,MAAD,EACbC,mBAAS,IADI,mBAC9BC,EAD8B,KACxBC,EADwB,OAEbF,mBAAS,IAFI,mBAE9BG,EAF8B,KAExBC,EAFwB,OAGHJ,mBAAS,IAHN,mBAG9BK,EAH8B,KAGnBC,EAHmB,KAerC,OACE,kBAAC,IAAD,KACE,kBAAC,IAAD,KACE,kBAAC,IAAD,KACE,kBAAC,IAAD,CAAMC,MAAM,8BAAZ,8OAOJ,kBAAC,IAAD,KACE,kBAAC,IAAD,KACE,kBAAC,IAAD,KACE,kBAAC,IAAD,CAAMA,MAAM,SACV,kBAAC,IAAD,KACE,kBAAC,IAAD,CAAKC,GAAI,IACP,kBAAC,IAAD,KACE,kBAAC,IAAKC,MAAN,CAAYC,UAAU,kBACpB,kBAAC,IAAKC,MAAN,qBACA,kBAAC,IAAKC,QAAN,CACEC,aAAcZ,EACda,GAAG,OACHC,SAjCH,KACjB,IAAIC,EAAWC,SAASC,eAAe,QAAQC,MAC/CjB,EAAQc,GACRV,EAAac,YAAyBJ,EAASK,MAAM,IAAKlB,EAAKkB,MAAM,KAAKC,KAAK,MA+B3DC,KAAK,OACLC,YAAY,iBAEd,kBAAC,IAAKC,KAAN,CAAWC,UAAU,cAArB,8BAEF,kBAAC,IAAKjB,MAAN,CAAYC,UAAU,gCACpB,kBAAC,IAAKC,MAAN,sBACA,kBAAC,IAAKC,QAAN,CACEC,aAAcV,EACdW,GAAG,OACHC,SAvCH,KACjB,IAAIY,EAAYV,SAASC,eAAe,QAAQC,MAChDf,EAAQuB,GACRrB,EAAac,YAAyBnB,EAAKoB,MAAM,IAAKM,EAAUN,MAAM,KAAKC,KAAK,MAqC5DC,KAAK,OACLC,YAAY,iBAEd,kBAAC,IAAKC,KAAN,CAAWC,UAAU,cAArB,mCAMV,kBAAC,IAAD,CAAMnB,MAAM,UACV,uBAAGmB,UAAU,QAAQrB,EAAUuB,OAAS,EAAI,MAAQvB,U,gCCnElE,YACewB,gBAAmB,c,gCCInB,SAAST,EAAyBU,EAAMC,GAErD,MAAMC,EAAYC,MAAMF,EAAKH,OAAS,GACnCM,KAAK,MACLC,IAAI,IAAMF,MAAMH,EAAKF,OAAS,GAAGM,KAAK,OAGzC,IAAK,IAAIE,EAAc,EAAGA,GAAeN,EAAKF,OAAQQ,GAAe,EACnEJ,EAAU,GAAGI,GAAe,EAI9B,IAAK,IAAIC,EAAW,EAAGA,GAAYN,EAAKH,OAAQS,GAAY,EAC1DL,EAAUK,GAAU,GAAK,EAI3B,IAAK,IAAIA,EAAW,EAAGA,GAAYN,EAAKH,OAAQS,GAAY,EAC1D,IAAK,IAAID,EAAc,EAAGA,GAAeN,EAAKF,OAAQQ,GAAe,EAC/DN,EAAKM,EAAc,KAAOL,EAAKM,EAAW,GAC5CL,EAAUK,GAAUD,GAAeJ,EAAUK,EAAW,GAAGD,EAAc,GAAK,EAE9EJ,EAAUK,GAAUD,GAAeE,KAAKC,IACtCP,EAAUK,EAAW,GAAGD,GACxBJ,EAAUK,GAAUD,EAAc,IAO1C,IAAKJ,EAAUD,EAAKH,QAAQE,EAAKF,QAE/B,MAAO,CAAC,IAGV,MAAMY,EAAkB,GACxB,IAAIJ,EAAcN,EAAKF,OACnBS,EAAWN,EAAKH,OAEpB,KAAOQ,EAAc,GAAKC,EAAW,GAC/BP,EAAKM,EAAc,KAAOL,EAAKM,EAAW,IAE5CG,EAAgBC,QAAQX,EAAKM,EAAc,IAC3CA,GAAe,EACfC,GAAY,GACHL,EAAUK,GAAUD,KAAiBJ,EAAUK,GAAUD,EAAc,GAEhFA,GAAe,EAGfC,GAAY,EAIhB,OAAOG,EA5DT","file":"static/js/14.3ea2f0fd.chunk.js","sourcesContent":["import React, { useState } from \"react\";\nimport { Row, Col, Form, CardDeck } from \"react-bootstrap\";\n\nimport Aux from \"../../hoc/_Aux\";\nimport Card from \"../../App/components/MainCard\";\nimport longestCommonSubsequence from \"../../Algorithms/LongestCommonSubsequence\";\n\nconst LongestCommonSubsequence = () => {\n  const [str1, setStr1] = useState(\"\");\n  const [str2, setStr2] = useState(\"\");\n  const [commonStr, setCommonStr] = useState(\"\");\n\n  const updateStr1 = () => {\n    let firstSeq = document.getElementById(\"str1\").value;\n    setStr1(firstSeq);\n    setCommonStr(longestCommonSubsequence(firstSeq.split(\"\"), str2.split(\"\")).join(\"\"));\n  };\n  const updateStr2 = () => {\n    let secondSeq = document.getElementById(\"str2\").value;\n    setStr2(secondSeq);\n    setCommonStr(longestCommonSubsequence(str1.split(\"\"), secondSeq.split(\"\")).join(\"\"));\n  };\n  return (\n    <Aux>\n      <Row>\n        <Col>\n          <Card title=\"Longest Common Subsequence\">\n            Longest Common Subsequence Problem has two sequences and we have to find the length of\n            longest subsequence present in both of them. A subsequence is a sequence that appears in\n            the same relative order, but not necessarily contiguous.\n          </Card>\n        </Col>\n      </Row>\n      <Row>\n        <Col>\n          <CardDeck>\n            <Card title=\"Input\">\n              <Row>\n                <Col md={12}>\n                  <Form>\n                    <Form.Group controlId=\"formBasicEmail\">\n                      <Form.Label>First String</Form.Label>\n                      <Form.Control\n                        defaultValue={str1}\n                        id=\"str1\"\n                        onChange={updateStr1}\n                        type=\"text\"\n                        placeholder=\"My String...\"\n                      />\n                      <Form.Text className=\"text-muted\">Kindly Input First String</Form.Text>\n                    </Form.Group>\n                    <Form.Group controlId=\"exampleForm.ControlTextarea1\">\n                      <Form.Label>Second String</Form.Label>\n                      <Form.Control\n                        defaultValue={str2}\n                        id=\"str2\"\n                        onChange={updateStr2}\n                        type=\"text\"\n                        placeholder=\"My String...\"\n                      />\n                      <Form.Text className=\"text-muted\">Kindly Input Second String</Form.Text>\n                    </Form.Group>\n                  </Form>\n                </Col>\n              </Row>\n            </Card>\n            <Card title=\"Output\">\n              <p className=\"ml-3\">{commonStr.length < 1 ? \"---\" : commonStr}</p>\n            </Card>\n          </CardDeck>\n        </Col>\n      </Row>\n    </Aux>\n  );\n};\n\nexport default LongestCommonSubsequence;\n","import createWithBsPrefix from './createWithBsPrefix';\nexport default createWithBsPrefix('card-deck');","/**\n * @param {string[]} set1\n * @param {string[]} set2\n * @return {string[]}\n */\nexport default function longestCommonSubsequence(set1, set2) {\n  // Init LCS matrix.\n  const lcsMatrix = Array(set2.length + 1)\n    .fill(null)\n    .map(() => Array(set1.length + 1).fill(null));\n\n  // Fill first row with zeros.\n  for (let columnIndex = 0; columnIndex <= set1.length; columnIndex += 1) {\n    lcsMatrix[0][columnIndex] = 0;\n  }\n\n  // Fill first column with zeros.\n  for (let rowIndex = 0; rowIndex <= set2.length; rowIndex += 1) {\n    lcsMatrix[rowIndex][0] = 0;\n  }\n\n  // Fill rest of the column that correspond to each of two strings.\n  for (let rowIndex = 1; rowIndex <= set2.length; rowIndex += 1) {\n    for (let columnIndex = 1; columnIndex <= set1.length; columnIndex += 1) {\n      if (set1[columnIndex - 1] === set2[rowIndex - 1]) {\n        lcsMatrix[rowIndex][columnIndex] = lcsMatrix[rowIndex - 1][columnIndex - 1] + 1;\n      } else {\n        lcsMatrix[rowIndex][columnIndex] = Math.max(\n          lcsMatrix[rowIndex - 1][columnIndex],\n          lcsMatrix[rowIndex][columnIndex - 1]\n        );\n      }\n    }\n  }\n\n  // Calculate LCS based on LCS matrix.\n  if (!lcsMatrix[set2.length][set1.length]) {\n    // If the length of largest common string is zero then return empty string.\n    return [\"\"];\n  }\n\n  const longestSequence = [];\n  let columnIndex = set1.length;\n  let rowIndex = set2.length;\n\n  while (columnIndex > 0 || rowIndex > 0) {\n    if (set1[columnIndex - 1] === set2[rowIndex - 1]) {\n      // Move by diagonal left-top.\n      longestSequence.unshift(set1[columnIndex - 1]);\n      columnIndex -= 1;\n      rowIndex -= 1;\n    } else if (lcsMatrix[rowIndex][columnIndex] === lcsMatrix[rowIndex][columnIndex - 1]) {\n      // Move left.\n      columnIndex -= 1;\n    } else {\n      // Move up.\n      rowIndex -= 1;\n    }\n  }\n\n  return longestSequence;\n}\n"],"sourceRoot":""}