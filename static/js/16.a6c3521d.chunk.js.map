{"version":3,"sources":["Screens/Strings/WordBreak.js","../node_modules/react-bootstrap/esm/CardDeck.js","Algorithms/LongestCommonSubsequence.js"],"names":["WordBreak","useState","dictionary","setDictionary","myString","setMyString","wordBreak","setWordBreak","init","setInit","title","isOption","setSample","sampleNum","console","log","md","Group","controlId","Label","Control","defaultValue","id","onChange","document","getElementById","value","longestCommonSubsequence","split","join","type","placeholder","Text","className","createWithBsPrefix","set1","set2","lcsMatrix","Array","length","fill","map","columnIndex","rowIndex","Math","max","longestSequence","unshift"],"mappings":"6MAiFeA,UA1EG,KAAO,MAAD,EACcC,mBAAS,IADvB,mBACfC,EADe,KACHC,EADG,OAEUF,mBAAS,IAFnB,mBAEfG,EAFe,KAELC,EAFK,OAGYJ,mBAAS,OAHrB,mBAGfK,EAHe,KAGJC,EAHI,OAIEN,oBAAS,GAJX,mBAIfO,EAJe,KAITC,EAJS,KAqBtB,OACE,kBAAC,IAAD,KACE,kBAAC,IAAD,KACE,kBAAC,IAAD,KACE,kBAAC,IAAD,CAAMC,MAAM,cAAZ,yJAMJ,kBAAC,IAAD,KACE,kBAAC,IAAD,KACE,kBAAC,IAAD,KACE,kBAAC,IAAD,CAAMA,MAAM,QAAQC,UAAQ,EAACC,UAhBpBC,IACjBC,QAAQC,IAAIF,KAgBF,kBAAC,IAAD,KACE,kBAAC,IAAD,CAAKG,GAAI,IACP,kBAAC,IAAD,KACE,kBAAC,IAAKC,MAAN,CAAYC,UAAU,kBACpB,kBAAC,IAAKC,MAAN,0BACA,kBAAC,IAAKC,QAAN,CACEC,aAAcnB,EACdoB,GAAG,aACHC,SArCG,KACvB,IAAIrB,EAAasB,SAASC,eAAe,cAAcC,MACvDvB,EAAcD,GACdK,EAAaoB,YAAyBzB,EAAW0B,MAAM,IAAKxB,EAASwB,MAAM,KAAKC,KAAK,KACrFpB,GAAQ,IAkCYqB,KAAK,OACLC,YAAY,gCAEd,kBAAC,IAAKC,KAAN,CAAWC,UAAU,cAArB,mCAEF,kBAAC,IAAKhB,MAAN,CAAYC,UAAU,gCACpB,kBAAC,IAAKC,MAAN,qBACA,kBAAC,IAAKC,QAAN,CACEC,aAAcjB,EACdkB,GAAG,WACHC,SA1CC,KACrB,IAAInB,EAAWoB,SAASC,eAAe,YAAYC,MACnDrB,EAAYD,GACZG,EAAaoB,YAAyBzB,EAAW0B,MAAM,IAAKxB,EAASwB,MAAM,KAAKC,KAAK,KACrFpB,GAAQ,IAuCYqB,KAAK,OACLC,YAAY,eAEd,kBAAC,IAAKC,KAAN,CAAWC,UAAU,cAArB,2CAQV,kBAAC,IAAD,CAAMvB,MAAM,UAAUF,EAAQF,EAAY,WAAa,eAAkB,a,gCCzErF,YACe4B,gBAAmB,c,gCCInB,SAASP,EAAyBQ,EAAMC,GAErD,MAAMC,EAAYC,MAAMF,EAAKG,OAAS,GACnCC,KAAK,MACLC,IAAI,IAAMH,MAAMH,EAAKI,OAAS,GAAGC,KAAK,OAGzC,IAAK,IAAIE,EAAc,EAAGA,GAAeP,EAAKI,OAAQG,GAAe,EACnEL,EAAU,GAAGK,GAAe,EAI9B,IAAK,IAAIC,EAAW,EAAGA,GAAYP,EAAKG,OAAQI,GAAY,EAC1DN,EAAUM,GAAU,GAAK,EAI3B,IAAK,IAAIA,EAAW,EAAGA,GAAYP,EAAKG,OAAQI,GAAY,EAC1D,IAAK,IAAID,EAAc,EAAGA,GAAeP,EAAKI,OAAQG,GAAe,EAC/DP,EAAKO,EAAc,KAAON,EAAKO,EAAW,GAC5CN,EAAUM,GAAUD,GAAeL,EAAUM,EAAW,GAAGD,EAAc,GAAK,EAE9EL,EAAUM,GAAUD,GAAeE,KAAKC,IACtCR,EAAUM,EAAW,GAAGD,GACxBL,EAAUM,GAAUD,EAAc,IAO1C,IAAKL,EAAUD,EAAKG,QAAQJ,EAAKI,QAE/B,MAAO,CAAC,IAGV,MAAMO,EAAkB,GACxB,IAAIJ,EAAcP,EAAKI,OACnBI,EAAWP,EAAKG,OAEpB,KAAOG,EAAc,GAAKC,EAAW,GAC/BR,EAAKO,EAAc,KAAON,EAAKO,EAAW,IAE5CG,EAAgBC,QAAQZ,EAAKO,EAAc,IAC3CA,GAAe,EACfC,GAAY,GACHN,EAAUM,GAAUD,KAAiBL,EAAUM,GAAUD,EAAc,GAEhFA,GAAe,EAGfC,GAAY,EAIhB,OAAOG,EA5DT","file":"static/js/16.a6c3521d.chunk.js","sourcesContent":["import React, { useState } from \"react\";\nimport { Row, Col, Form, CardDeck } from \"react-bootstrap\";\n\nimport Aux from \"../../hoc/_Aux\";\nimport Card from \"../../App/components/MainCard\";\nimport longestCommonSubsequence from \"../../Algorithms/LongestCommonSubsequence\";\n\nconst WordBreak = () => {\n  const [dictionary, setDictionary] = useState(\"\");\n  const [myString, setMyString] = useState(\"\");\n  const [wordBreak, setWordBreak] = useState(\"---\");\n  const [init, setInit] = useState(false);\n\n  const updateDictionary = () => {\n    let dictionary = document.getElementById(\"dictionary\").value;\n    setDictionary(dictionary);\n    setWordBreak(longestCommonSubsequence(dictionary.split(\"\"), myString.split(\"\")).join(\"\"));\n    setInit(true);\n  };\n  const updateMyString = () => {\n    let myString = document.getElementById(\"myString\").value;\n    setMyString(myString);\n    setWordBreak(longestCommonSubsequence(dictionary.split(\"\"), myString.split(\"\")).join(\"\"));\n    setInit(true);\n  };\n  const setSample = (sampleNum) => {\n    console.log(sampleNum);\n  };\n  return (\n    <Aux>\n      <Row>\n        <Col>\n          <Card title=\"Word Break\">\n            Given an input string and a dictionary of words, find out if the input string can be\n            segmented into a space-separated sequence of dictionary words.\n          </Card>\n        </Col>\n      </Row>\n      <Row>\n        <Col>\n          <CardDeck>\n            <Card title=\"Input\" isOption setSample={setSample}>\n              <Row>\n                <Col md={12}>\n                  <Form>\n                    <Form.Group controlId=\"formBasicEmail\">\n                      <Form.Label>Input Disctionary</Form.Label>\n                      <Form.Control\n                        defaultValue={dictionary}\n                        id=\"dictionary\"\n                        onChange={updateDictionary}\n                        type=\"text\"\n                        placeholder=\"Cat Dog Apple Man Butter...\"\n                      />\n                      <Form.Text className=\"text-muted\">Kindly Input Words with Spaces</Form.Text>\n                    </Form.Group>\n                    <Form.Group controlId=\"exampleForm.ControlTextarea1\">\n                      <Form.Label>Input String</Form.Label>\n                      <Form.Control\n                        defaultValue={myString}\n                        id=\"myString\"\n                        onChange={updateMyString}\n                        type=\"text\"\n                        placeholder=\"myapple...\"\n                      />\n                      <Form.Text className=\"text-muted\">\n                        Kindly Input string without spaces\n                      </Form.Text>\n                    </Form.Group>\n                  </Form>\n                </Col>\n              </Row>\n            </Card>\n            <Card title=\"Output\">{init ? (wordBreak ? \"Possible\" : \"Not Possible\") : \"---\"}</Card>\n          </CardDeck>\n        </Col>\n      </Row>\n    </Aux>\n  );\n};\n\nexport default WordBreak;\n","import createWithBsPrefix from './createWithBsPrefix';\nexport default createWithBsPrefix('card-deck');","/**\n * @param {string[]} set1\n * @param {string[]} set2\n * @return {string[]}\n */\nexport default function longestCommonSubsequence(set1, set2) {\n  // Init LCS matrix.\n  const lcsMatrix = Array(set2.length + 1)\n    .fill(null)\n    .map(() => Array(set1.length + 1).fill(null));\n\n  // Fill first row with zeros.\n  for (let columnIndex = 0; columnIndex <= set1.length; columnIndex += 1) {\n    lcsMatrix[0][columnIndex] = 0;\n  }\n\n  // Fill first column with zeros.\n  for (let rowIndex = 0; rowIndex <= set2.length; rowIndex += 1) {\n    lcsMatrix[rowIndex][0] = 0;\n  }\n\n  // Fill rest of the column that correspond to each of two strings.\n  for (let rowIndex = 1; rowIndex <= set2.length; rowIndex += 1) {\n    for (let columnIndex = 1; columnIndex <= set1.length; columnIndex += 1) {\n      if (set1[columnIndex - 1] === set2[rowIndex - 1]) {\n        lcsMatrix[rowIndex][columnIndex] = lcsMatrix[rowIndex - 1][columnIndex - 1] + 1;\n      } else {\n        lcsMatrix[rowIndex][columnIndex] = Math.max(\n          lcsMatrix[rowIndex - 1][columnIndex],\n          lcsMatrix[rowIndex][columnIndex - 1]\n        );\n      }\n    }\n  }\n\n  // Calculate LCS based on LCS matrix.\n  if (!lcsMatrix[set2.length][set1.length]) {\n    // If the length of largest common string is zero then return empty string.\n    return [\"\"];\n  }\n\n  const longestSequence = [];\n  let columnIndex = set1.length;\n  let rowIndex = set2.length;\n\n  while (columnIndex > 0 || rowIndex > 0) {\n    if (set1[columnIndex - 1] === set2[rowIndex - 1]) {\n      // Move by diagonal left-top.\n      longestSequence.unshift(set1[columnIndex - 1]);\n      columnIndex -= 1;\n      rowIndex -= 1;\n    } else if (lcsMatrix[rowIndex][columnIndex] === lcsMatrix[rowIndex][columnIndex - 1]) {\n      // Move left.\n      columnIndex -= 1;\n    } else {\n      // Move up.\n      rowIndex -= 1;\n    }\n  }\n\n  return longestSequence;\n}\n"],"sourceRoot":""}