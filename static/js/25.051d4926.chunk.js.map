{"version":3,"sources":["Screens/Sets/LongestIncreasingSubsequence.js","Algorithms/LongestIncreasingSubsequence.js","../node_modules/react-bootstrap/esm/CardDeck.js"],"names":["LongestIncreasingSubsequence","useState","seq","longest","setLongest","key","values","graphData","setGraphData","Row","Col","title","md","CardDeck","Form","Group","Label","Control","defaultValue","id","onChange","graph","data","document","getElementById","value","split","map","item","parseInt","isNaN","length","pop","sequence","lengthsArray","Array","fill","previousElementIndex","currentElementIndex","newLength","longestIncreasingLength","i","longestIncreasingSubsequence","forEach","push","type","placeholder","Text","className","width","tooltip","enabled","datum","x","y","height","showValues","createWithBsPrefix"],"mappings":"sNAqFeA,UA7EsB,KAAO,MAAD,EACnBC,mBAAS,IADU,mBAClCC,EADkC,aAEXD,mBAAS,IAFE,mBAElCE,EAFkC,KAEzBC,EAFyB,OAGPH,mBAAS,CACzC,CACEI,IAAK,oBACLC,OAAQ,MAN6B,mBAGlCC,EAHkC,KAGvBC,EAHuB,KAwBzC,OACE,kBAAC,IAAD,KACE,kBAACC,EAAA,EAAD,KACE,kBAACC,EAAA,EAAD,KACE,kBAAC,IAAD,CAAMC,MAAM,kCAAZ,qMAOJ,kBAACF,EAAA,EAAD,KACE,kBAACC,EAAA,EAAD,CAAKE,GAAI,IACP,kBAACC,EAAA,EAAD,KACE,kBAAC,IAAD,CAAMF,MAAM,SACV,kBAACF,EAAA,EAAD,KACE,kBAACC,EAAA,EAAD,KACE,kBAACI,EAAA,EAAD,KACE,kBAACA,EAAA,EAAKC,MAAN,KACE,kBAACD,EAAA,EAAKE,MAAN,sBACA,kBAACF,EAAA,EAAKG,QAAN,CACEC,aAAchB,EACdiB,GAAG,8BACHC,SArCJ,KAChB,IAAIC,EAAQ,CACRhB,IAAK,oBACLC,OAAQ,IAEVgB,EAAOC,SAASC,eAAe,+BAA+BC,MAAMC,MAAM,KAC5EJ,EAAOA,EAAKK,IAAKC,GAASC,SAASD,IAC/BE,MAAMR,EAAKA,EAAKS,OAAS,KAAKT,EAAKU,MACvC5B,ECnBW,SAAwC6B,GAIrD,MAAMC,EAAeC,MAAMF,EAASF,QAAQK,KAAK,GAEjD,IAAIC,EAAuB,EACvBC,EAAsB,EAE1B,KAAOA,EAAsBL,EAASF,QAAQ,CAC5C,GAAIE,EAASI,GAAwBJ,EAASK,GAAsB,CAKlE,MAAMC,EAAYL,EAAaG,GAAwB,EACnDE,EAAYL,EAAaI,KAG3BJ,EAAaI,GAAuBC,GAKxCF,GAAwB,EAIpBA,IAAyBC,IAC3BA,GAAuB,EACvBD,EAAuB,GAM3B,IAAIG,EAA0B,EAE9B,IAAK,IAAIC,EAAI,EAAGA,EAAIP,EAAaH,OAAQU,GAAK,EACxCP,EAAaO,GAAKD,IACpBA,EAA0BN,EAAaO,IAI3C,OAAOD,EDzBME,CAA6BpB,IACxCA,EAAKqB,QAAQ,CAAClB,EAAOpB,KACnBgB,EAAMf,OAAOsC,KAAK,CAAEvC,MAAKoB,YAE3BjB,EAAa,CAACa,KA0BMwB,KAAK,OACLC,YAAY,cAEd,kBAAChC,EAAA,EAAKiC,KAAN,CAAWC,UAAU,cAArB,wCAMV,kBAAC,IAAD,CAAMC,MAAM,MAAMtC,MAAM,UAAxB,mCACmCR,EACjC,kBAAC,IAAD,CACE+C,QAAS,CAAEC,SAAS,GACpBN,KAAK,mBACLO,MAAO7C,EACP8C,EAAE,MACFC,EAAE,QACFC,OAAQ,IACRN,MAAO,IACPO,YAAU,W,gCE3E1B,YACeC,gBAAmB","file":"static/js/25.051d4926.chunk.js","sourcesContent":["import React, { useState } from \"react\";\nimport { Row, Col, Form, CardDeck } from \"react-bootstrap\";\nimport NVD3Chart from \"react-nvd3\";\n\nimport Aux from \"../../hoc/_Aux\";\nimport Card from \"../../App/components/MainCard\";\nimport longestIncreasingSubsequence from \"../../Algorithms/LongestIncreasingSubsequence\";\n\nconst LongestIncreasingSubsequence = () => {\n  const [seq, setSeq] = useState([]);\n  const [longest, setLongest] = useState(0);\n  const [graphData, setGraphData] = useState([\n    {\n      key: \"Cumulative Return\",\n      values: [],\n    },\n  ]);\n\n  const updateLIS = () => {\n    let graph = {\n        key: \"Cumulative Return\",\n        values: [],\n      },\n      data = document.getElementById(\"longest_increasing_sequence\").value.split(\" \");\n    data = data.map((item) => parseInt(item));\n    if (isNaN(data[data.length - 1])) data.pop();\n    setLongest(longestIncreasingSubsequence(data));\n    data.forEach((value, key) => {\n      graph.values.push({ key, value });\n    });\n    setGraphData([graph]);\n  };\n  return (\n    <Aux>\n      <Row>\n        <Col>\n          <Card title=\"Longest Increasing Subsequence\">\n            The Longest Increasing Subsequence (LIS) problem is to find the length of the longest\n            subsequence of a given sequence such that all elements of the subsequence are sorted in\n            increasing order.\n          </Card>\n        </Col>\n      </Row>\n      <Row>\n        <Col md={12}>\n          <CardDeck>\n            <Card title=\"Input\">\n              <Row>\n                <Col>\n                  <Form>\n                    <Form.Group>\n                      <Form.Label>Number Series</Form.Label>\n                      <Form.Control\n                        defaultValue={seq}\n                        id=\"longest_increasing_sequence\"\n                        onChange={updateLIS}\n                        type=\"text\"\n                        placeholder=\"1 2 3 ...\"\n                      />\n                      <Form.Text className=\"text-muted\">Kindly Input Numbers with space</Form.Text>\n                    </Form.Group>\n                  </Form>\n                </Col>\n              </Row>\n            </Card>\n            <Card width=\"70%\" title=\"Output\">\n              Longest Increasing Subsequence: {longest}\n              <NVD3Chart\n                tooltip={{ enabled: true }}\n                type=\"discreteBarChart\"\n                datum={graphData}\n                x=\"key\"\n                y=\"value\"\n                height={300}\n                width={400}\n                showValues\n              />\n            </Card>\n          </CardDeck>\n        </Col>\n      </Row>\n    </Aux>\n  );\n};\n\nexport default LongestIncreasingSubsequence;\n","/**\n * Dynamic programming approach to find longest increasing subsequence.\n * Complexity: O(n * n)\n *\n * @param {number[]} sequence\n * @return {number}\n */\nexport default function dpLongestIncreasingSubsequence(sequence) {\n  // Create array with longest increasing substrings length and\n  // fill it with 1-s that would mean that each element of the sequence\n  // is itself a minimum increasing subsequence.\n  const lengthsArray = Array(sequence.length).fill(1);\n\n  let previousElementIndex = 0;\n  let currentElementIndex = 1;\n\n  while (currentElementIndex < sequence.length) {\n    if (sequence[previousElementIndex] < sequence[currentElementIndex]) {\n      // If current element is bigger then the previous one then\n      // current element is a part of increasing subsequence which\n      // length is by one bigger then the length of increasing subsequence\n      // for previous element.\n      const newLength = lengthsArray[previousElementIndex] + 1;\n      if (newLength > lengthsArray[currentElementIndex]) {\n        // Increase only if previous element would give us bigger subsequence length\n        // then we already have for current element.\n        lengthsArray[currentElementIndex] = newLength;\n      }\n    }\n\n    // Move previous element index right.\n    previousElementIndex += 1;\n\n    // If previous element index equals to current element index then\n    // shift current element right and reset previous element index to zero.\n    if (previousElementIndex === currentElementIndex) {\n      currentElementIndex += 1;\n      previousElementIndex = 0;\n    }\n  }\n\n  // Find the biggest element in lengthsArray.\n  // This number is the biggest length of increasing subsequence.\n  let longestIncreasingLength = 0;\n\n  for (let i = 0; i < lengthsArray.length; i += 1) {\n    if (lengthsArray[i] > longestIncreasingLength) {\n      longestIncreasingLength = lengthsArray[i];\n    }\n  }\n\n  return longestIncreasingLength;\n}\n","import createWithBsPrefix from './createWithBsPrefix';\nexport default createWithBsPrefix('card-deck');"],"sourceRoot":""}